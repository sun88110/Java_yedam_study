======================[1교시]
NEW연산자는 전부다 인스턴스 멤버라
생각하는게 좋!다

인스턴스 멤버란?
객체를 생성한 후 사용할 수 있는 필드와 메서드

this란?
생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우
필드임을 지정해주기 위해 주로 사용

정적 멤버란? <- 임마는 접근할때 클래스 명으로 접근
클래스에 고정된 멤버로서 객체를 생성하지않고
사용할 수 있는 필드와 메소드

만약 시간을 각각의 시간을 갖고 있다면 문제가 생긴다
고로 이같은 공통기준을 정적 멤버로 선언한다

인스턴스를 선언하고 클래스를 만들면 
이미 객체가 있어서 선언이 가능하다

정적 메소드 : 인스턴스 멤버를 사용불가
따라서 인스턴스 안에 this를 사용할 수 없다
그러나 같은 정적(스테틱) 메소드는 사용이 가능하다
따라서 정적 메소드 안에서도 똑같은 메소드가 필요하다면
스테틱 메소드 안에 만들어라
이에 관한 예제는 0605패키지의 Car.java이다 

인스턴스 멤버와 정적메소드의 의미차이를 알아라
★정적 멤버는 this가 안된다.
☆정적 멤버는 목적에 따라 사용하는데 주의해야한다

객체 지향 프로그래밍 언어는 4가지 요건을 만족해야한다
1. 추상화 <- 클래스를 선언하는게 1빠
2. 캡슐화 <- 정보은닉
: 객체의 속성과 동작을 하나로 + 외부에서의 직접적인 접근 제한
3. 상속    <- 썩씨딩..유!빠더..
4. 다형성 <- 이샛긴 면접에서 대놓고 나온다

달달 외우지말고 이해 해라
자바는 겁나 애매하기 때매
(프로그램 개발 , DOM 이해)에 대한 개념을 헷갈려한다.

클래스의 6챕터,7챕터가 끝나면
위 개념이 어떻게 녹아져있는지 
4가지를 설명할 수 있어야 한다.

클래스란 디테일한 정보는 배제하고
공통된 부분만 객체를 정의하는 것이 추상화이다.

캡슐화는 패키지에서 설명해주겠다.

그러면 대충 개념만 알면되는가?
아니아니아니아니다.

이제 디자인 패턴에 대해 알아보겠다.

디자인패턴이란 뭣이여?
임마는 우리 위대하신 IT조상님들께서
어린 형제자매들을 위하여
특정 상황에서 제작된 클래스들을 보니까
이 프로그램안에서는 이 객체가 자주 쓰이더라
해서 하나의 패턴으로 정의해둔 코딩 기법이다

인스턴스가 많으면 좋은가?
아니다 이게 많으면 관리할게 많아져서 힘들어
이를 대응하기 위한 패턴이

싱글톤 패턴이다.
DB는 한번의 커넥션이 66개 까지 이루어진다
이 말은 칼라로 이어질 수 있는게 66명까지다.
근데 한 회사에서 20~66개를 다 땡겨버리면
다른곳에선 접근이 안되서 월급루팡 쌀숭이가 되어버린다.
이를 고치기위해 싱글톤으로
하나의 인스터스 기반으로 통일시켜서
가용성을 떡☆상 시킬 수 있다.

사용법은
public class 클래스명 {
//정적 필드
private static 클래스 singleton = new 클래스();

//생성자
private 클래스() {}

//정적 메소드 
static 클래스 geInstance() {
	return singleton;
}
요로코롬 사용하면된다 이 특징을 보자면
정적 필드와 정적 메소드에서 쓴다는것을 알게될것이며
private 로 선언을해서 혼자서 북치고장구치고 가능하다.

======================[2교시]

메인에
Singleton obj1 = Singleton.geInstance();
Singleton obj2 = Singleton.geInstance();
이렇게 선언하여 동등비교를 한다면
if(obj1 == obj2) { 
System.out.println("같은 객체입니다.");
}else {
System.out.println("다른 객체입니다.");
} 
같은 객체라고 나온다.

동등비교를 하는 이유는
장군이 왕에게 제대로 충성하고 있는지,
하나의 객체를 가르키고 있는지 확인하기 위함이다.
왕이 둘이면 장군을 ★숙청☆ 해야겟지?

싱글톤의 기본은 final이다.
private final static 이름 singleton = new 이름();
final이 붙으면 기본적으로 상수를 의미한다

상수는 값이 변하지않는다 따라서 이 녀석은 초기값이 필요함
인스턴스 필드에서는 어지간해선 초기값을 주지않음
하지만 인스턴스 별로 고정값이 필요하다면
    // 추가적인 상수 필드
    private final String apiEndpoint = "https://api.example.com";
    private final int timeoutSeconds = 30;
    private final String appVersion = "1.0.0";
이런식으로 선언해서 써주도록하자.

상수는 불변성을 보장받기 쉽지않다.
일단은 그렇다.

//인스턴스 필드 + final => 인스턴스 별로 고정값을 가져야하는 경우
final String name;
public Earth(String name){
	this.name = name;
}

// 불변성을 가진 데이터 => 상수 (기본타입)
// 정적필드 + final, 이름 = 대문자 + 스네이크 표기법
static final double EARTH_RADIUS = 
	6400;
final static double EARTH_AREA = 
	4 * Math.PI * EARTH_RADIUS * EARTH_RADIUS;

객체의 메소드를 불러올때
S는 상수, F는 final 이다.

스트링 자체의 불변성이 아니라 
리터럴(입력값) 자체의 불변성을 가진다

일단 알아야되는게 final 변수가 선언되었다면
그 변수에 값이 채워져 있어야 컴파일이 가능하다

이제부터 패키지를 보겠다
패키지는 물리적으로 폴더를 의미한다.
클래스의 전체 이름은 패키지 + 클래스를 사용해서
다음과 같이 표현한다.

상위 패키지 com
      |- 하위 패키지 mycompany (A 클래스)
      ㄴ 하위 패키지 yourcompany (B 클래스)

======================[3교시]

IT 분야에서 가장 빡센건
AI랑 정보보안이다

패키지 이름 규칙
1. 숫자로 시작 불가
2. _및 $제외한 특수문자 사용 불가
3. Java로 시작하는 패키지는 자바 표준 API로 선빵쳐서 불가
4. 모두 소문자로 작성하는 것이 관례

패키지의 모든것을 가져오겠다 싶으면
import com.yedam.java.* 
이렇게 패키지 밑에 있는 모든것을 가져오겠다는 것이다.

그러나 같은 코드안에 같은 이름을 가진 패키지를
사용하는 것은 권장하지 않는다.

만약 import를 하지않으면
com.yedam.java.ch0605.Car neCar
  = new com.yedam.java.ch0605.Car();
이렇게 지저분하게 써야된다.

1. 패키지 명은 기본적으로 단어 3개이상 쓸것 
(그래야만 3번째 단어아래에 생성되서 4개가 됨)
2. 패키지명의 단어는 기본적으로 역순으로 읽어들임.
(naver.com은 com.naver.web.user이런식으로 패키지안에 있따)

결론은 위대한 양키 조상님들께서 만들어두신 결과물은
import 상위패키지.하위패키지.클래스이름;
import 상위패키지.하위패키지.*;
이런식으로 쓰라는 구절로 전해져내려오고있다.


접속 제한자에 대해 알아보자
클래스와 인터페이스 및 이들이 가진 멤버의 접근 제한

이 접속 제한자는 사황으로 구성되어 있다

public 접근 제한자
첫번째 사황은 온건파로 박애주의자. 
모든 난민을 수용하듯 모든 접근 가능
protected 접근 제한자
두번째 사황은 애국보수.
 같은 패키지 또는 자식만 사용가능
private 접근 제한
세번째 사황은 강경파로 독재자. 
지혼자 사용가능한 이기주의다.
default 접근 제한
네번째 사황은 히키코모리.
마지막으로 public과 private의 사이에 있는 사황이다.
public > default > private 기본값이다.
같은 패키지만 사용가능

클래스의 접근제한자 보다 넓은 접근 제한자는
멤버에 사용불가능하다.

클래스에 퍼블릭이 없을시 만약
패키지 배진욱과 패키지 도우서가 있다.
배진욱에게 연필이 할당되어있다면
도우서에게 연필을 사용할 수 수없다.

만약 퍼플릭이 되어있다면 만약
패키지 김현태와 패키지 김동우가 있따.
만약 김현태가 퍼블릭 지우개가 할당되어 있다면
김동우는 퍼블릭 지우개를 사용할 수 있다.

클래스가 퍼플릭으로 선언되어잇을때만 
퍼블릭와 프로택티드를 인스턴스에 선언할 수 있다.

퍼블릭으로 인스턴스를 선언한다면
다른 패키지에서 인스턴스 생성 가능 (new 연산자)

프로택티드로 선언한다면
같은 패키지 또는 자식만 사용가능


//필드 선언
퍼플릭은 static으로만 생성 가능하다.
기본적으로 private으로 필드 선언한다.

//메소드 선언
가장 대표적으로 public 그다음으로 많이 쓰는게 private

private는 내부에서 밖으로 사용을 안한다.
메소드는 기본적으로 기능단위로 들어간다.
외부에 선언되는것중 노출되고싶지않은 처리정보는
private로 처리한다.

======================[4교시]

생성자가 퍼블릭이라도 클래스가 퍼블릭이 아니라면
다른 패키지에서 생성자에 접근할 수 없다.

즉 문은 열려 있어도
건물 출입이 금지되어 있으면
문을 사용할 수 없다.

Getter, Setter 메서드가 뭔지 알아보자
객체의 무결성에 사용된다.
정보은닉에 관한 것 중 하나가 캡슐화 이다.

캡슐화를 하면 정보은닉이 뽀너스로 적용된다
DB의 정확성,유효성,일괄성이 무결성을 형성따지는데
자바는 데이터의 유효성만 따진다

유효성 체크를 생각해보자
정확한 값이 들어갔는지 확인할때.
https://hamait.tistory.com/342
위의 링크를 들어가서 확인해보자
정규표현식은 복잡하고 특정한 규칙을 가진 
문자열을 처리할 때 사용하는 기법이다

Getter, Setter는 무조껀 써야되는
이 험난한 개발자 자바환경의 필수사항이다

Setter 메소드란?
외부의 값을 받아 필드의 값을 변경하는것이 목적이다
매개값을 검증하여 유효한 값만 필드로 저장할 수 있다.

이놈이 유효성 체크의 핵심이다.
  메소드, 매개변수, 리턴타입 
이게 시그니처이다.
리턴타입은 기본적으로 void
메서드 이름은 set으로 시작하고 변경하려는
필드명이 필요하다 set + 필드명
그리고 무조껀 매개변수가 있어야한다.

이 뜻은 한꺼번에 모든 값을 변경하지 않는다.
하나하나씩 해결한다.

다음은 Getter이다.
외부에 내가 가진 값을 반환할때 사용한다.
필드값을 가공해서 외부로 전달할 수도 있다.
예를들면 미국이랑 한국사이에
섭씨,화씨
야드,파운드
레터,리갈 
등등

Getter를 선언할때는
매개변수가 있어도되고 없어도되고
보통 인스턴스를 생성할때 
아에 값을 집어넣어버린다.
선언할때는 타입 + get필드명() 이다

void구문에서
public void setSpeed(int speed) {
if (speed < 0) { // speed는 음수일 수 없음.
	this.speed = 0;
	return;
}
this.speed = speed;	
}
여기서 if문을 종료하면서 메소드를 종료할때
return을 사용한다 
반복문을 종료할땐 break;

======================[5교시]
223페이지 커스텀 문제
메뉴1) 학생수 입력
메뉴2) 점수 입력
이름, 국어점수, 수학점수, 영어점수 를 한번에 받겠다.
메뉴3) 점수리스트
이름, 국어점수, 수학점수, 영어점수 를 한번에 받겠다.
메뉴4) 분석
국어점수 중 최고점 받은 학생이름, 국어점수
수학점수 중 최고점 받은 학생이름, 수학점수
영어점수 중 최고점 받은 학생이름, 영어점수

======================[6교시]
======================[7교시]
======================[8교시]
집합관계 , 상속관계, 사용관계
상속을 이용하면 부모 클래스만 건들여도 
자식 클래스들이 수정되서 유지보수 시간을 최소화 가능
extends라는 애는 무조껀 상속을 불러온다
임마는 자식이 부모를 결정하는것인데
1. 부모는 여러명이 될 수 없다.
2. 자식이라도 private에도 접근할 수 없다.
3. 접근 제한자의 default 접근제어자는 같은 패키지에서만
접근 가능 이를 대응하기 위한게 protected
protected는 같은 패키지 + 다른 패키지의 자식까지 허용

상속이란?
it에서는 코드를 물려준다
자식 개체가 부모 개체에 찾아가서 코드를
갖고온다. 애초에 스택 영역에 생성될때 부모가 생성되고
자식이 같이 생성된다.

┌─────────────────────┐
│ Child 객체           		          │
│ ├─ Parent 필드 영역                             │ ← 부모 멤버
│ ├─ Child 필드 영역                               │ ← 자식 멤버
└─────────────────────┘

======================[9교시]

부모를 상속한 자식을 생성자로 불러오게 된다면
자식 클래스의 생성자 안에는 부모 클래스의 생성자가
숨어 있다 

생성자로 부모쪽에 로그를 찍고 자식을 호출하면
부모가 생성되어서 로그가 찍히는 것을 볼 수 있다.

자식 클래스가 부모 생성자를 호출 할때 쓰는 명칭은
super라고 한다
부모 생성자를 호출 할때는 
반드시 첫번째 줄에서 호출하라

여기서 몬다이
this는 왜 부모쪽에서 호출할까
그것은 바로 this는 엄밀이 말하면 자식의 것이기 때문이다.
근데 자식에게 해당 필드를 가지고있지 않다면
부모의 호주머니를 털어서 this가 있다면
부모의 필드 사용한다.

super는 어차피 내일 다시 말한건데
다시말하자면 이녀석은 메서드 오버라이딩이다.

오버라이딩은 부모가 갖고있는 메서드를
자식이 본인 입맛대로 수정해서 사용을 할 수 있다
여기서 중요한건 이렇게 수정한다고해서 부모의
메서드가 수정되는 것은 아니다
그리고 부모가 퍼블릭으로 설정된것을 프라이빗으로
다운그레이드를 하진 못한다