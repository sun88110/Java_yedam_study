==============================[1교시]
별찍기 실습

==============================[2교시]

스택

메모리 영역
클래스, 정적필드, 상수, 생성자, 메소드, 코드 등을 분류해서 저장

힙 영역
객체와 배열을 저장하는 영역

JVM 스택 영역
변수값이 저장될때 PUSH POP

깃에 있는 자바에서 챕터05에
0501 패키지에 레퍼런스 커먼에 코드를 보면
method는
class referenceCommonExample과
static void main과
static boolean firstMethod가 있음

스택을 보면
main method에 첫번째로 실행되는것이
자바 어딘가의 힙 영역에 저장된 Hello world가 
msg 101(임의)에 담겨진 상태로 main method 지하 깊숙한
바닥에 msg가 깔려있음

그리고 first method에 첫번쨰로 깔려 있는게
v1이라는 변수에 char타입의 값이 담긴상태로 first method
지하 깊숙한 바닥에 깔려있음 그 위에 이제
if 라는 블럭이 first method 위에 깔리고
그 안에 v2 , v3이 들어가고 if가 종료가 되면
if라는 블럭이 날라감 그럼 다시 first method가 들어남 


==============================[3교시]

참조타입의 str은
같은 값을 가르키는 다른 변수
		String str1 = "신용권";
		String str2 = "신용권";
가 있을때 str2 = "짱용권" 으로 바꾼다면
str1은 바뀌지않고 str2에 임의의 다른 "짱용권"을 가진다
이것이 str의 특징

String name1 = new String("수@은");
String name2 = new String("경@단");

이런식으로 객체를 생성할 수 있!다! 이놈들은 
	if(name1 == name2) 
로 비교를 하게 된다면 같은 값이라도 
객체는 서로 다른 주소값 이기 때문에
동등비교시 서로 다르다 로 판단한다.

그래서 사용하는게
name1.equals.name2 라고 한다
이걸로 비교하면 야물딱지게 비교가 가능하다
대소문자 상관없이 비교하고싶다면 
equalsIgnoreCase()를 사용하라

===============

그러나 참조 타입의 int는
같은 주소를 가지고있는것을 바꾼다면
		int[] first = {1,2,3};
		int[] second = first;
		second[1] = 10;
first[1]은 10이 되어버린다!!
이것이 int의 위험성!
왜 이런가 하면 str과 int는 목적이 달라서 그런것이다!

===============
이제 null을 보자
null은 이짜식은 어딜가든 차별받는 니--거 다
그래서 이 니--거는 힙 영역에 가르키는게 없어서
이놈을 활용해서 로직을 구현한다면 NullPointerExecption이라는
후드 스타일의 오류 구문을 버어어어어어억하고 띄워버린다

===============
이제 배열을 보자
자바의 배열은 같은 타입의 데이터만 저장가능하고
한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다.

배열 변수 선언은 
int[]  변수, double[] 변수,  string[] 변수, 로 하는데
int 변수[], double 변수[], string 변수[]로 할 수 도 있는데 <- 이건 잘 쓰는 방식이 아니다
타입[] 변수 = {값1, 값2, 값3 ...} ; <- 이렇게 진행하면 자동으로 배열의 길이만큼 크기를 결정한다
new 연산자를 사용하여 
int[] soures = new int[30]; 으로 하면 초기값이 없이 길이를 줄 수 있다

=============================[4교시]

자ㅏㅏㅏ배열은 보자ㅏㅏㅏ
우리는 배열 길이를 볼떄
변수.length를 하잖음? 근데 임마는 ReadOnly라서
length의 수치를 변경 할 수 없다.

2차원 배열

int[][] scores = new int[2][3]

다차원 배열 계단식 구조
int[][] scores = new int[2][]
scores[0] = new int[2];
scores[1] = new int[3];

=============================[5교시]

얕은 복사 / 깊은 복사
얕은 복사는 같은 객체를 공유
깊은 복사는 배열 자체를 공유

System.arraycopy()를 이용한 복사는 
깊은 복사를 쉽게 사용가능한 방법이다

System.arraycopy(Object src, int srcPos,/여기까지 원본
 object dest, int destPos,/여기까지 복사 int length/이게 원본의 길이);

자바스크립트에서는 for of라고 쓰는게 있는데
자바에서는 향상된 for문이라고 쓰는게 있다
이 녀석은 배열의 전체 데이터만큼 순환하는 for문
	=> 기본적으로 index를 사용하지 않음

=============================[8교시]

그 전교시에는 자소서 쓰는법 배움

객체란?
물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에
자신의 속성을 가지며 식별이 가능한 것

속성이란?
속성(필드) & 동작(메소드)로 구성

객체 간의 관계?
1. 집합 관계 : 부품과 완성품의 관계
2. 사용 관계 : 객체 간의 상호작용
3. 상속 관계 : 상위객체를 기반으로 하위 객체를 생성

클래스(class)
자바의 설계도
인스턴스 : 클래스로부터 만들어진 객체

클래스의 두 용도
1. 라이브러리
2. 